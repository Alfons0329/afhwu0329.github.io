# leetcode_OJ WC106 è§£é¡Œå¿ƒå¾—
* é€™æ¬¡å…¨éƒ¨è§£å®Œï¼Œç¬¬å››é¡Œå±…ç„¶åªåœ¨ä¸€å ‚é€šè­˜èª²å®Œæˆ ğŸ˜€
## PA. [922. Sort Array By Parity II](https://leetcode.com/contest/weekly-contest-106/problems/sort-array-by-parity-ii/) æ°´é¡Œ

* é¡Œæ„ï¼šä¾ç…§å¥‡æ•¸å¶æ•¸æ’åºé™£åˆ—
* æƒ³æ³•ï¼šæ°´é¡Œç›´æ¥åšå³å¯
* åˆ†æï¼šTime complexity O(N), Space complexity O(1)

```cpp
class Solution 
{
public:
    vector<int> sortArrayByParityII(vector<int>& A) 
    {
        int n = A.size();
        
        int odd[n]={0};
        int even[n]={0};
        int optr = 0, eptr = 0;
        for(int i = 0; i < n; i++)
        {
            if(A[i] & 1) 
            {
                odd[optr++] = A[i];
            }
            else
            {
                even[eptr++] = A[i];
            }
        }
        
        optr = 0, eptr = 0;
        
        for(int i = 0; i < n; i++)
        {
            if(i & 1)
            {
                A[i] = odd[optr++];
            }
            else
            {
                A[i] = even[eptr++];
            }
        }
        
        return A;
    }
};
```

## PB. [921. Minimum Add to Make Parentheses Valid](https://leetcode.com/contest/weekly-contest-106/problems/minimum-add-to-make-parentheses-valid/) æ‹¬è™Ÿé…å°å‰©é¤˜æ•¸

* é¡Œæ„ï¼šçµ¦å·¦å³æ‹¬è™Ÿå­—ä¸²ï¼Œå•è‡³å°‘è¦åŠ ä¸Šå¹¾å€‹å·¦å³æ‹¬è™Ÿæ‰èƒ½ä½¿æ‹¬è™Ÿé…å°æˆåŠŸï¼Œä¾‹å¦‚ ` ((( ` æ¬ ç¼ºä¸‰å€‹ã€`()))((` æ¬ ç¼ºå››å€‹ï¼ˆå·¦äºŒå³äºŒï¼‰
* æƒ³æ³•ï¼šé‡åˆ°å·¦æ‹¬è™Ÿè¡¨ç¤ºæ¬ é…å°ï¼Œå°‡to_match è®Šæ•¸åŠ èµ·ä¾†ï¼Œé‡åˆ°åˆæ‹¬è™Ÿå†å°‡å…¶éæ¸›ï¼Œå€˜è‹¥to_matchåˆå¤ªå¤šäº†ä»£è¡¨å³æ‹¬è™Ÿéå¤šï¼Œå†ç”¨ç¬¬äºŒå€‹è®Šæ•¸lackè¡¨ç¤º
* åˆ†æï¼šTime complexity O(N), Space complexity O(1)

```cpp
class Solution 
{
public:
    int minAddToMakeValid(string S) 
    {
        int n = S.size(), lack = 0, to_match = 0;
        
        for (int i = 0; i < n; i++)
		{
            if (S[i] == '(')
			{
				to_match++;
			}
			else if (S[i] == ')')
			{
				if (to_match >= 1)
				{
					to_match--;
				}
				else
				{
                    lack++;
				}
			}
		}
        return to_match + lack;
    }
};
```

## PC. [923. 3Sum With Multiplicity](https://leetcode.com/contest/weekly-contest-106/problems/3sum-with-multiplicity/) çµ„åˆå•é¡Œ

* é¡Œæ„ï¼šçµ¦ä¸€å€‹æ•¸å­—æ–¼é™£åˆ—ä¸­ï¼Œå–ä¸‰å€‹ä¸é‡è¤‡çš„æ•¸å­—a b cä½†æ˜¯a b cæ•¸å€¼ä¸ä¸€å®šè¦ç›¸ç•°ï¼Œå†çµ¦å®šä¸€ç›®æ¨™targetï¼Œå• a + b + c = target ä¹‹çµ„åˆæƒ…å½¢
* æƒ³æ³•ï¼šæœ¬ä»¥ç‚ºé€™é¡Œæœ‰é»åƒèƒŒåŒ…å•é¡Œï¼Œä½†æ²’æœ‰é‚£éº¼é›£ï¼Œè¼ƒè¿‘ä¼¼æ•¸å­¸çµ„åˆå•é¡Œ
    * é¦–å…ˆç”¨mapå°‡å„å€‹æ•¸å­—çš„æ•¸é‡å­˜èµ·ä¾†
    * ç”±æ–¼æ•¸å­—æœ€å¤šåˆ°101ï¼Œå› æ­¤å¯ä»¥åˆ©ç”¨ 101 * 101æš´åŠ›æœå°‹ï¼ˆä¸ç”¨åˆ°ç¬¬ä¸‰å€‹å›åœˆï¼Œåªè¦çœ‹mapä¸­æ˜¯å¦å­˜åœ¨å³å¯ï¼Œäº¦å³ 
    ```
    if(my[thr] == 0 || my[it2] == 0) //unable to use
    {
        continue;
    }
    ```
    * ç‚ºäº†é˜²æ­¢é‡è¤‡ï¼Œæˆ‘å€‘æœƒå¸Œæœ›æ•¸å­—æ˜¯éå¢çš„ï¼ˆä½†ä¸å¿…åš´æ ¼å¢ï¼Œå¦å‰‡ 2 + 2 + 3 = 7 é€™ç¨®å°±æ‰¾ä¸åˆ°äº†ï¼‰ï¼Œäº¦å³
    ```
    if(!(fir <= sec && sec <= thr)) //maLLain the order to prevent duplicated
    {
        continue;
    }
    ```
    * åœ¨æŸ¥çœ‹å„ç¨®æ–¹æ³•çš„çµ„åˆæ•¸ï¼š C(a,1) * C(b,1) * C(c,1)   or   C(a,2) * C(b,1)    or    C(a,3)
* åˆ†æï¼šTime complexity O(101^2), Space complexity O(1)

## PD. [924. Minimize Malware Spread](https://leetcode.com/contest/weekly-contest-106/problems/minimize-malware-spread/) DFSæ‰¾å‡ºæœ€å¤šé€£é€šçš„èµ·é»
* é¡Œæ„ï¼šçµ¦åœ–ä¸­çš„æ•¸å€‹é»ï¼Œå•å“ªä¸€å€‹é»å‡ºç™¼é–‹å§‹åšDFSå¯ä»¥é€£é€šæœ€å¤šé»
* æ€è·¯ï¼šæ¯ä¸€å€‹é»éƒ½DFSä¸€æ¬¡ï¼Œæ¯”è¼ƒå‡ºèƒ½è¯é€šæœ€å¤šé»çš„èµ·é»ï¼Œä¸¦ä¸”æ‰¾å‡ºIDæœ€å°çš„ï¼ˆå¾å¾Œé¢æ‰¾å›ä¾†å³å¯ï¼‰
* åˆ†æï¼šTime complexity O(N^2), Space complexity O(N)

```cpp
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) 
    {
        //check which node be removed will remove the most connection
        int n = initial.size(), m = graph.size();
        sort(initial.begin(), initial.end());
        vector<int> color_cnt(m,0); //do not use n, otherwise runtime error will occurred such as [0,9] will out of the array bound with length 2
        
        //count how much nodes can be traversed from the starting point
        for(int i = 0; i < n; ++i)
        {
            int each_cnt = 0;
            vector<bool> traversed(m, false);
            DFS(graph, initial[i], traversed, each_cnt);
            color_cnt[initial[i]] = each_cnt;
        }
        int res = INT_MAX, max_color = 0;
        
        for(int i = n - 1; i >= 0; --i)
        {
            if(color_cnt[initial[i]] >= max_color)
            {
                res = initial[i];
                max_color = color_cnt[initial[i]];
            }
        }
        return res;
    }
    void DFS(vector<vector<int>>& graph, int cur_node, vector<bool>& traversed, int& each_cnt)
    {
        if(traversed[cur_node]) //traversed node, return
        {
            return;
        }
        traversed[cur_node] = true;
        each_cnt++;
        for(int i = 1; i < graph[cur_node].size(); ++i)
        {
            if(graph[cur_node][i]) //traversable and not traversed, travese it
            {
                DFS(graph, i, traversed, each_cnt);
            }
        }
        return; //end traverse of current node
    }
};
```